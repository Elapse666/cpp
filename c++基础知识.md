## 1.1 数据类型

数据类型在32位系统所占内存和64位系统所占内存不一样

| **数据类型**        | **占用空间**                                    | 取值范围         |
| ------------------- | ----------------------------------------------- | ---------------- |
| char(字符型)        | 1字节                                           | (-2^7 ~ 2^7-1)   |
| short(短整型)       | 2字节                                           | (-2^15 ~ 2^15-1) |
| int(整型)           | 4字节                                           | (-2^31 ~ 2^31-1) |
| long(长整形)        | Windows为4字节，Linux为4字节(32位)，8字节(64位) | (-2^31 ~ 2^31-1) |
| long long(长长整形) | 8字节                                           | (-2^63 ~ 2^63-1) |
| float               | 4字节                                           | 7位有效数字      |
| double              | 8字节                                           | 15～16位有效数字 |



## 1.2 指针变量和普通变量的区别

普通变量存放的是数据,指针变量存放的是地址 

指针变量可以通过" * "操作符，操作指针变量指向的内存空间，这个过程称为解引用



## 1.3 指针所占内存空间

所有指针类型在32位操作系统下是4个字节

所有指针类型在64位操作系统下是8个字节



```c++
#include <iostream>
using namespace std;
int main() {
	cout << sizeof(char) << endl;		//1
	cout << sizeof(short) << endl;		//2
	cout << sizeof(int) << endl;		//4
	cout << sizeof(long) << endl;		//4
	cout << sizeof(long long) << endl;	//8
	cout << sizeof(float) << endl;		//4
	cout << sizeof(double) << endl;		//8

	cout << sizeof(char*) << endl;		//4
	cout << sizeof(short*) << endl;		//4
	cout << sizeof(long*) << endl;		//4
	cout << sizeof(long long*) << endl;	//4
	cout << sizeof(float*) << endl;		//4
	cout << sizeof(double*) << endl;	//4

	return 0;
}
```



## 1.4 空指针和野指针

### 空指针

空指针：指针变量指向内存中编号为0的空间 

用途：初始化指针变量 

注意：空指针指向的内存是不可以访问的



### 野指针

野指针：指针变量指向非法的内存空间



## 1.5 常量指针和指针常量

const修饰指针有三种情况 

const修饰指针 --- 常量指针		const int * p1 = &a;

const修饰常量 --- 指针常量		int * const p2 = &a;

const即修饰指针，又修饰常量	const int * const p3 = &a;

辨别方法：

忽略类型int，看const右侧紧跟着的是指针* 还是常量p1, 是指针*就是常量指针，是常量p1就是指针常量。



```c++
int main() 
{
	int a = 10;
	int b = 10;

	//const修饰的是指针，指针指向可以改，指针指向的值不可以更改
	const int * p1 = &a; 
	p1 = &b; //正确
	//*p1 = 100;  报错
	
	//const修饰的是常量，指针指向不可以改，指针指向的值可以更改
	int * const p2 = &a;
	//p2 = &b; //错误
	*p2 = 100; //正确

    //const既修饰指针又修饰常量
	const int * const p3 = &a;
	//p3 = &b; //错误
	//*p3 = 100; //错误
    
	return 0;
}
```



## 1.6 指针和函数

作用：利用指针作函数参数，可以修改实参的值

```c++
//值传递
void swap1(int a ,int b)
{
	int temp = a;
	a = b; 
	b = temp;
}
//地址传递
void swap2(int * p1, int *p2)
{
	int temp = *p1;
	*p1 = *p2;
	*p2 = temp;
}

int main() {

	int a = 10;
	int b = 20;
	swap1(a, b); // 值传递不会改变实参

	swap2(&a, &b); //地址传递会改变实参

	cout << "a = " << a << endl;

	cout << "b = " << b << endl;

	return 0;
}
```

```c++
//值传递
a = 10;
b = 20;

//地址传递
a = 20;
b = 10;
```



## 1.7 指针和引用

指针是一个变量，存放的是对象的地址，指针初始化时可以为空，p=&a可以改变指针指向的地址，*p可以改变指针指向的地址上储存的值。指针作为参数进行传递时，实际是将实参的一个拷贝传递给形参，两者指向同一块地址，但不是同一个变量，在函数中改变这个变量的指向不会影响实参的指向。

引用相当于给一个对象起别名，初始化时必须引用一个已经存在的对象，不可以为空，同时引用必须从一而终，不可以改变引用的对象。引用作为参数进行传递时，实际是将实参的别名传递给形参，两者是同一个变量，在函数中修改形参也会修改实参。

```c++
#include <iostream>
using namespace std;
·
void swapNum1(int* a, int* b) {
	int temp = *a;
	*a = *b;
	*b = temp;
}

void swapNum2(int& a, int& b) {
	int temp = a;
	a = b;
	b = temp;
}


int main() {
	int x = 10;
	int y = 20;
	
	int m = 10;
	int n = 20;
	
	swapNum1(&x, &y);
	cout << "x = " << x <<" y = " << y << endl;
	
	swapNum2(m, n);
	cout << "m = " << m <<" n = " << n << endl;
	
	return 0;
}
```

```
//指针
x = 20;
y = 10;

//引用
m = 20;
n = 10;
```



##  1.8 在main执行之前和之后执行的代码可能是什么？

### 1.8.1 在main函数执行之前，会进行初始化系统相关资源：

1、设置栈指针

2、初始化静态变量`static `和全局变量`global`

3、对全局变量赋初值，比如`int` `long` 等类型赋为0，`bool`类型赋为`false`等。

4、全局对象调用构造函数对这些对象的状态和数据进行初始化。

5、将main函数的参数传递给main函数。

### 1.8.2 在main函数执行之后

1、全局对象调用析构函数对这些对象进行清理，包括释放内存等。



## 1.9 结构体内存对齐问题

结构体的内存按照结构体中size最大的成员对齐，比如size最大的成员为double，那么所有的成员都以8字节对齐。

其中，`alignof`可以**计算**出类型的对齐方式，`alignas`可以**指定**结构体的对齐方式

但如果`alignas`指定的内存size小于size最大的成员，则`alignas`不起作用。



## 1.10 在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？-TODO

1、需要返回函数内局部变量的内存的时候用指针

2、对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小

3、类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式



### 1.11 堆和栈的区别

​		区别：

| 区别         |                              栈                              |                              堆                              |
| ------------ | :----------------------------------------------------------:                 | :----------------------------------------------------------: |
| 分配方式     | 栈区的内存由系统分配和释放，比如在函数中定义一个变量，栈区就会自动分配内存给这个变量 | 堆区的内存由程序员申请和释放，比如使用new和molloc申请内存，使用delete和free释放内存。 |
| 存放的数据   |      栈区存放局部变量、函数参数、返回数据、返回的地址。                            |     堆区存放全局变量和用new和molloc申请的内存上的数据。      |
| 地址是否连续 |            栈区的地址连续的，栈区由栈顶向栈底扩展                                  |        堆区的地址不是连续的，堆区由低地址向高地址扩展        |
| 申请效率     |              栈区申请分配内存速度快，不会有碎片                                  |                 堆区分配内存速度慢，会有碎片                 |
| 溢出         | 局部数据过多或局部数组越界。（例如递归深度大）。解决方法：多用动态分配，形参多用引用 |                    动态分配对象用完没释放                    |
| 优势         |       分配效率高，不会产生内存碎片，自动申请、自动释放                             |                            空间大                            |
| 劣势         |                            空间小                                              |        分配效率低，会产生内存碎片，手动申请、手动释放        |



## 1.12 区别以下指针类型？

```c++
int *p[10]
    表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量
int (*p)[10]
    表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10
int *p(int)
    表示函数声明，函数名是p，参数是int类型的，返回值是int *类型的
int (*p)(int)
    表示函数指针，强调是指针，该指针指向的函数的参数是int类型的，并且返回值是int类型的
```



## 1.13 new / delete 与 malloc / free的异同

使用方法：

```c++
#include <cstdlib>

int main() {
 
    // 使用 new 分配内存并调用构造函数
    int *ptr = new int;
    // 记得在使用完之后释放内存
    delete ptr;
    
    // 使用 malloc 分配内存
    int *ptr = (int *)malloc(sizeof(int));
    // 记得在使用完之后释放内存
    free(ptr);
}
```

区别：

|          | new / delete                                                 | malloc / free                                                |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 本质属性 | C++运算符                                                    | C++/C语⾔的标准库函数                                        |
| 内存分配 | 自动分配内存大小，从⾃由存储区上为对象动态分配内存           | 手动分配内存大小，从堆上动态分配内存                         |
| 运行特点 | 除了分配和释放内存，还会调用构造和析构函数 <br />返回定义时具体类型的指针<br />内存分配失败会抛出bad_alloc异常<br />opeartor new/opertor delete可重载 | 只分配和释放内存<br />返回void类型指针，使用时需要进行类型转换<br />内存分配失败返回null <br />malloc不允许重载 |
| 安全性   | 安全 (一个int类型指针指向float会报错)                        | 不安全 (malloc类型转换成int，分配double数据类型大小的内存空间不会报错) |
| 两者关系 | new封装了malloc                                              |                                                              |



## 1.14 宏定义和函数有何区别

### 用法：

```c++
#define PI 3.14159
#define MAX(a, b) ((a) > (b) ? (a) : (b))

float area = PI * radius * radius;
int maxNum = MAX(x, y);
```

### 区别：

宏定义通常用于定义**常量**、**简单的函数**或**代码片段的重用**

宏定义在预处理阶段完成文本替换，相当于程序运行时被替换的文本直接插入代码，不存在函数调用，执行起来更快；函数在运行时需要跳转到具体调用函数，速度相对慢一点。

宏定义参数没有类型，不会进行类型检查，不安全；函数参数具有类型，需要进行类型检查。



## 1.15 宏定义和typedef区别

### 用法：

```cpp
#define MAX_SIZE 100
#define PI       3.1415926

typedef unsigned char uint8_t
typedef unsigned int  uint32_t
```

### 区别：

#### 工作方式：

宏定义是一种预处理指令，宏主要用于定义常量及简单的函数；

typedef是一种类型定义指令，使用`typedef`关键字来定义一个已有类型的新名称。

#### 类型检查：

宏定义不涉及类型检查；`typedef`会对类型进行检查

#### 作用范围：

宏定义是全局有效的，会对整个文件中出现的宏的引用进行替换

typedef遵循 C++ 的作用域规则，在该定义所在的作用域内有效



## 1.16 define 和 inline 的区别

宏定义（#define）和内联函数（inline）都是为了**减少函数调用开销和提高代码运行效率**而引入的机制

### 用法：

```cpp
//宏定义
#define MAX(a, b) ((a) > (b) ? (a) : (b))

int result = MAX(10, 20);  // 替换为 int result = ((10) > (20) ? (10) : (20));

//内联函数
inline int max(int a, int b) {
    return (a > b) ? a : b;
}

int result = max(10, 20);  // 直接将函数体代码嵌入到这里
```

### 区别：

#### 宏定义：

宏定义通常用于定义常量、简单的函数或代码片段的重用。

宏定义在预处理阶段完成文本替换，相当于程序运行时被替换的文本直接插入代码，不存在函数调用，执行起来更快。

宏定义没有类型检查和语法分析，代码安全性低。

#### 内联函数：

内联函数是将函数的代码嵌入到调用点，类似于将函数体直接复制到调用处。这样做可以避免函数调用的开销，但会增加代码的大小

内联函数进行参数类型检查，具有返回值，可以实现重载。代码安全性高。

内联函数只是一个建议，代码长或者函数体内有循环 / 递归的函数编译器优化时会自动忽略掉内联函数，选择函数调用。



## 1.17 变量声明和定义区别

变量声明大多数在.h文件中，变量定义大多数在.c文件中

变量声明是指在程序中声明一个变量的**存在**，告诉编译器该变量的**名称**和**类型**，但**不可以赋值**，也不分配内存空间

变量定义是指在程序中定义一个变量的**类型、名称，也可以赋初值**，并为其**分配内存空间**

相同变量可以在多处声明（外部变量extern），但只能在一处定义



## 1.18 C++从代码到可执行程序经历了什么？

四个过程，**预编译、编译、汇编、链接**

### 预编译：

主要处理源代码文件中的以“#”开头的预编译指令：

1、删除所有`#define` ，并且展开所有的宏定义

2、处理所有的条件预编译指令，比如：`#if`	`#elif`	 `#else`	 `#endif`	`#ifdef`	`#ifndef`。

3、处理`#include`预编译指令，将被包含的文件插入到该预编译指令的位置。

4、删除所有的注释，“//”和“/**/”

5、添加行号和文件名标识

### 编译：

**将`.c`文件生成`.s`文件**

1、词法分析：将源代码的字符序列分割成一系列的记号。

2、语法分析：对记号进行语法分析，产生语法树。

3、语义分析：判断表达式是否有意义。

4、代码优化。

5、目标代码生成：生成汇编代码。

6、目标代码优化。

### 汇编：

**将`.s`文件生成`.o`文件**

将汇编代码转换成机器可以执行的二进制文件

### 链接：

将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序

链接分为静态链接和动态链接。

静态链接，是在链接的时候就**把要调用的代码和库复制并嵌入到最终生成的可执行文件中**，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。

而动态链接，是在链接的时候没有把调用的函数代码链接进入可执行文件，**而是在执行的过程中，再去找要链接的函数**，生成的可执行文件中没有函数代码，只包含函数的地址映射。所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。



## 1.19 strlen和sizeof区别？



sizeof是运算符，用于获取变量或数据类型的大小，即所占用的字节数

- sizeof(变量)：获取指定变量的所占内存的大小；
- sizeof(数据类型)：获取指定数据类型所占内存的大小；

```
string str = "abcdefg";
int num = 10;

cout << sizeof(str) << endl;		//28
cout << sizeof(int) << endl;		//4
```

strlen是库函数，用于计算字符串的长度，即字符串中字符的个数。

```
const char str[] = "abcdefg";
cout << strlen(str) << endl;		//7		7个字符个数
```



## 1.20 C++和C语言的区别-TODO

1、C++是面向对象的编程语言，提供了类、对象、继承、多态等特性；C语言是面向过程的编程语言；

2、C++可以定义类和对象来进行编程，C语言没有类和对象的概念。

3、C++拥有一个非常强大的C++标准库STL，这个库里包含了很多类和函数，用于处理文件、字符串、容器等任务。



## 1.21 C++的三大特性

封装、继承、多态

### 封装：

把成员变量和成员函数封装在一个单元中，称为类，对外提供公有、保护、私有三种访问权限。

```cpp
class Shape {
public:
    void setWidth(int w) {
        width = w;
    }
    void setHeight(int h) {
        height = h;
    }
protected:
    int width;
    int height;
};
```



### 继承：

继承是一种类之间的关系，通过继承机制，一个类可以从另一个类中继承属性和行为。被继承的类称为父类，继承得到属性和行为的类称为子类。继承可以实现代码的重用，并且可以通过在派生类中添加新的成员来扩展基类的功能。使用关键字`public`、`protected`和`private`来指定基类成员的访问权限。

```cpp
// 父类
class Shape {
public:
    void setWidth(int w) {
        width = w;
    }
    void setHeight(int h) {
        height = h;
    }
protected:
    int width;
    int height;
};

// 子类
class Rectangle : public Shape {
public:
    int getArea() {
        return width * height;
    }
};
```

### 多态：

多态是它允许不同类型的对象对同一消息作出不同的响应。通俗来说就是，不同类型的对象引用相同名字的成员函数会由不同反应。

实现多态的两种方式：覆盖（override）和重载（overload）

#### 覆盖：

在父类中将一个成员函数声明为虚函数，然后在子类中可以重写这个成员函数，不同的子类重写这个成员函数可以实现不同的功能。

覆盖的函数的特点：

1、函数具有相同的名称。
2、函数具有相同的参数类型和数量。
3、函数具有相同的返回类型。
4、函数的父类中被重写的函数必须有virtual修饰

```cpp
// 基类
class Shape {
public:
    virtual void draw() {
        cout << "绘制形状" << endl;
    }
};

// 派生类
class Rectangle : public Shape {
public:
    void draw() override {
        cout << "绘制矩形" << endl;
    }
};

class Circle : public Shape {
public:
    void draw() override {
        cout << "绘制圆形" << endl;
    }
};
```

#### 重载：

重载是指相同作用域（同一个命名空间或者同一个类）中拥有相同的函数名，但具有不同的参数类型或参数数量的函数。 重载允许根据所提供的参数不同来调用不同的函数。

重载的函数的特点：

1、函数具有相同的名称。
2、函数具有不同的参数类型或参数数量。
3、函数返回类型可以相同或不同。
4、同一作用域，比如都是一个类的成员函数，或者都是全局函数

```cpp
class Shape {
public:
    void draw() {
        cout << "绘制形状" << endl;
    }

    void draw(int width) {
        cout << "绘制形状，宽度为：" << width << endl;
    }

    void draw(int width, int height) {
        cout << "绘制形状，宽度为：" << width << "，高度为：" << height << endl;
    }
};
```



## 1.21 类的三种访问权限

公有访问权限、保护访问权限、私有访问权限。

公有访问权限`public`：public的变量和函数在类的**内部**、**外部**、**派生类**中访问。

保护访问权限`protected`：protected的变量和函数只能在类的**内部**、**其派生类**中访问。

私有访问权限`private`：private的变量和函数只能在类的**内部**访问。



另外说一下：派生类对基类成员的访问形式有两种：

- 内部访问：由派生类中新增的**成员函数**对从基类继承来的成员的访问
- 外部访问：在派生类外部，通过派生类的对象对从基类继承来的成员的访问

两种访问形式都是通过成员函数对成员变量/函数进行访问，所以是一种内部访问。

## 1.22 类的三种继承权限

### public继承：

**公有继承**的特点是基类的**公有成员**和**保护成员**作为派生类的成员时，都保持**原有的状态**，而基类的私有成员任然是私有的，不能被这个派生类的子类所访问。

| 基类      | 子类      |
| --------- | --------- |
| public    | public    |
| protected | protected |
| private   | 无法继承  |

### protected继承：

**保护继承**的特点是基类的所有**公有成员**和**保护成员**都成为派生类的**保护成员**，并且只能被它的派生类成员函数或友元函数访问，基类的私有成员仍然是私有的。

| 基类      | 子类      |
| --------- | --------- |
| public    | protected |
| protected | protected |
| private   | 无法继承  |

### private继承：

**私有继承**的特点是基类的所有**公有成员**和**保护成员**都成为派生类的**私有成员**，并且不被它的派生类的子类所访问，基类的私有成员无法被继承。

| 基类      | 子类     |
| --------- | -------- |
| public    | private  |
| protected | private  |
| private   | 无法继承 |



## 1.23 C++中struct和class的区别

### 相同点：

struct和class同样拥有公有、保护和私有成员。

能用class实现的，用struct同样可以实现。

### 区别：

struct的默认成员类型是public，class的默认成员类型是private。

struct的默认继承权限是public，class的默认继承权限是private。

struct 不能用于定义模板参数，class 可以用于定义模板参数。



## 1.24 C语言和C++中struct的区别

1、C语言中的struct的成员只能有一种属性：public；C++中的struct中的成员拥有三种属性，public、protected、private。

2、C语言中的struct只能定义成员变量，不能定义成员函数；C++中的struct既可以定义成员变量也可以定义成员函数。

3、C语言中的struct没有构造函数和析构函数；C++中的struct可以有构造函数和析构函数。



## 1.25 C++中的const关键字

### const修饰变量：

当 `const` 修饰变量时，该变量将被视为只读变量，即不能被修改。

`const`变量在声明时必须进行初始化，一旦初始化后，其值就不能再被修改。

```cpp
const int x = 5;
x = 10;  // 错误，无法修改const变量的值
```

### const修饰函数参数：

当函数的参数声明为`const`时，意味着函数内部不能修改该参数的值。这样做可以确保函数不会意外地修改传入的参数。

```cpp
void print(const int x) {
    x = 10;  // 错误，无法修改const参数的值
    cout << x << endl;
}
```

### const修饰函数返回值：

当函数的返回值声明为`const`时，意味着返回的值是常量，不能被修改。这样做可以防止函数返回的值被修改

```c++
const int func() {
    int a = 10;
    return a;
}

int main() {
    const int b = func(); // b 的值为 10，不能被修改
    b = 20; // 编译错误，b 是只读变量，不能被修改
    return 0;
}
```

### const修饰成员函数：

当成员函数被声明为`const`时，表示该函数不会修改对象的任何成员变量。这样做可以确保在`const`对象上调用该成员函数时，不会对对象的状态产生任何副作用。

注意：const对象只能调用const成员。

```c++
class A {
public:
    int func() const {
        // 编译错误，不能修改成员变量的值
        m_value = 10;
        return m_value;
    }
private:
    int m_value;
};
```

### const修饰指针或引用：

常量指针		const int * p1 = &a;

const修饰指针所指向的地址上的值，可以理解为const修饰`*p1`，`*p1`不能改变，`p1`可以改变。

```c++
int a = 10;
int b = 10;
//const修饰指针所指向的地址上的值，指针指向可以改，指针指向的值不可以更改
const int * p1 = &a; 
p1 = &b; //正确
//*p1 = 100;  报错
```

指针常量		int * const p2 = &a;

const 关键字修饰的是指针本身，使得指针本身成为只读变量，可以理解为const修饰`p2`，`p2`不能改变，`*p2`可以改变。

```c++
int a = 10;
int b = 10;
//const 关键字修饰的是指针本身，指针指向不可以改，指针指向的值可以更改
int * const p2 = &a;
//p2 = &b; //错误
*p2 = 100; //正确
```

const即修饰指针，又修饰常量	const int * const p3 = &a;

const 关键字同时修饰了指针本身和指针所指向的变量，使得指针本身和所指向的变量都成为只读变量，可以理解为一个const修饰`p3`，一个const修饰`*p3`，所以`p3`不能改变，`*p3`也不能改变。

```c++
//const既修饰指针又修饰常量
const int * const p3 = &a;
//p3 = &b; //错误
//*p3 = 100; //错误
```

## const修饰引用：

常量引用是指引用一个只读变量的引用，因此不能通过常量引用修改变量的值。

```c++
const int a = 10;
const int& b = a;  // 声明一个常量引用，引用常量 a
b = 20;  // 错误，无法通过常量引用修改常量 a 的值
```



## 1.26 C++中的static关键字

### static数据的存储位置：

static数据存储在全局（静态）存储区，其中全局（静态）存储区分为DATA段和BSS段，DATA段存储已经初始化的全局静态变量和局部静态变量，BSS段存储未初始化的全局静态变量和局部静态变量。

### static 修饰全局变量：

static 修饰全局变量可以将变量的作用域限定在当前文件中，使得其他文件无法访问该变量。

同时，static 修饰的全局变量在程序启动时被初始化（可以简单理解为在执行 main 函数之前，会执行一个全局的初始化函数，在那里会执行全局变量的初始化），生命周期和程序一样长

```cpp
// a.cpp 文件
static int a = 10;  // static 修饰全局变量
int main() {
    a++;  // 合法，可以在当前文件中访问 a
    return 0;
}

// b.cpp 文件
extern int a;  // 声明 a
void foo() {
    a++;  // 非法，会报链接错误，其他文件无法访问 a
}
```

### static 修饰局部变量：

static 修饰局部变量可以使得变量在函数调用结束后不会被销毁，而是一直存在于内存中，而且static 修饰的静态局部变量只执行初始化一次,下次调用该函数时可以继续使用。

同时，由于 static 修饰的局部变量的作用域仅限于函数内部，所以其他函数无法访问该变量

```cpp
void foo() {
    static int count = 0;  // static 修饰局部变量
    count++;
    cout << count << endl;
}

int main() {
    foo();  // 输出 1
    foo();  // 输出 2
    foo();  // 输出 3
    return 0;
}
```

### static 修饰函数：

static 修饰函数可以将函数的作用域限定在当前文件中，使得其他文件无法访问该函数。

同时，由于 static 修饰的函数只能在当前文件中被调用，因此可以避免命名冲突和代码重复定义。

```cpp
// a.cpp 文件
static void foo() {  // static 修饰函数
    cout << "Hello, world!" << endl;
}

int main() {
    foo();  // 合法，可以在当前文件中调用 foo 函数
    return 0;
}

// b.cpp 文件
extern void foo(); // 声明 foo
void bar() {
    foo();  // 非法，会报链接错误，找不到 foo 函数，其他文件无法调用 foo 函数
}
```

## static 修饰类成员变量和函数：

static 修饰类成员变量和函数可以使得它们在所有类对象中共享，且不需要创建对象就可以直接访问。

```cpp
class MyClass {
public:
    static int count;  // static 修饰类成员变量
    static void foo() {  // static 修饰类成员函数
        cout << count << endl;
    }
};
// 访问：

MyClass::count;
MyClass::foo();
```



##  1.27 C++ 中 volatile 的作用

C++ 中的 volatile 关键字和 const 对应，用来修饰变量，volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改。遇到volatile 关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。

例子：

```cpp
#include<iostream>
 
using namespace std;
 
int main(void)
{
    volatile const int  a = 7;
    int  *p = &a;
    *p = 8;
    cout<<"a = " << a << endl ;
    return 0;
}
```

```
//如果没有使用volatile
a = 7

//如果使用volatile
a = 8
```



## 1.28 数组名和指针的区别

数组名不是真正意义上的指针，可以理解为**常指针**，所以数组名没有自增、自减等操作。

数组在作为函数参数时会退化为指向其首元素的**一般指针**



## 1.29 c++有哪几种构造函数

1. 默认构造函数：没有参数的构造函数，用于创建对象时不需要提供任何初始值。
2. 初始化构造函数：接收一个或多个参数，用于创建对象时提供初始值。
3. 拷贝构造函数：接收一个同类对象作为参数，用于创建一个新对象，新对象的成员变量与参数对象的成员变量相同。
4. 移动构造函数：接收一个同类对象的右值引用作为参数，用于创建一个新对象，同时将参数对象的资源所有权转移到新对象上，参数对象变为无效。
5. 转换构造函数（Conversion Constructor）：接收一个非类类型的参数，用于将非类类型转换为类类型对象。

```cpp
#include <iostream>
using namespace std;

class Person {
private:
    int age;

public:
    // 默认构造函数
    Person() {
        age = 0;
    }
    
    // 初始化构造函数
    Person(int ageVal) {
        age = ageVal;
    }

    // 拷贝构造函数
    Person(const Person& other) {
        age = other.age;
    }

    // 移动构造函数
    Person(Person&& other) noexcept {               // Person&& other 是右值引用
        age = other.age;
        other.age = 0;
    }

    // 转换构造函数
    Person(double ageVal) {
        age = static_cast<int>(ageVal);
    }

    void print() {
        cout << "Age: " << age << endl;
    }
};

int main() {
    // 使用默认构造函数创建对象
    Person p1;
    p1.print();  // 输出：Age: 0

    // 使用带参数构造函数创建对象
    Person p2(25);
    p2.print();  // 输出：Age: 25

    // 使用拷贝构造函数创建对象
    Person p3(p2);
    p3.print();  // 输出：Age: 25

    // 使用移动构造函数创建对象
    Person p4(move(p3));            // 右值应用的对象想要放入左值， 必须使用std::move, 即右值引用可以引用move以后的左值
    p4.print();  // 输出：Age: 25
    p3.print();  // 输出：Age: 0

    // 使用转换构造函数创建对象
    Person p5(20.5);
    p5.print();  // 输出：Age: 20

    return 0;
}
```

## 1.30 c++中explicit的作用

`explicit` 是一个关键字，用于修饰**类的构造函数**。当构造函数声明为 `explicit` 时，它将**禁止编译器执行隐式类型转换**，指定用户必须**显式地调用该构造函数**。优点：提高代码的可读性和安全性

```c++
class MyClass {
public:
    explicit MyClass(int x) {
        // 构造函数实现
    }
};

void func(MyClass obj) {
    // 函数体
}

int main() {
    MyClass obj1(10);  // 直接构造一个 MyClass 对象
    MyClass obj2 = 20;  // 错误，不允许隐式转换
    MyClass obj3 = MyClass(30);  // OK，显式转换
    MyClass obj4 = static_cast<MyClass>(40);  // OK，强制类型转换

    func(50);  // 错误，不允许隐式转换
    func(MyClass(60));  // OK，显式转换
    func(static_cast<MyClass>(70));  // OK，强制类型转换

    return 0;
}
```



## 1.30 c++中mutble的作用

mutable的中文意思是“可变的，易变的”，被mutable修饰的变量，将永远处于可变的状态。

`mutable` 是 C++ 中的一个关键字，用于修饰**类的成员变量**，表示该成员变量即使在一个`const`成员函数中也可以被修改。

通常来说，const修饰的成员函数中不能修改类的成员变量，但是如果该成员变量`mutable`修饰，则const修饰的成员函数中可以修改类的成员变量。

```c++
//示例1
class person
{
    int m_A;
    mutable int m_B;//特殊变量 在常函数里值也可以被修改
public:
    void add() const//在函数里不可修改this指针指向的值 常量指针
    {
        m_A = 10;//错误  不可修改值，this已经被修饰为常量指针
        m_B = 20;//正确
    }
};

//示例2
class person
{
public:
    int m_A;
    mutable int m_B;//特殊变量 在常函数里值也可以被修改
};

int main()
{
    const person p = person();//修饰常对象 不可修改类成员的值
    p.m_A = 10;//错误，被修饰了指针常量
    p.m_B = 200;//正确，特殊变量，修饰了mutable
}
```



## 1.30 c++中extern的作用

在C++中，`extern`是一个关键字，用于声明一个全局变量或者函数，表示该变量或函数是在其他文件中定义的。

`extern`的作用是使多个源文件共享同一个全局变量和函数。



## 1.31 C++中`extern "C"`的作用

`extern "C"`用于指定某个函数或变量按照C语言的链接规则进行编译和链接。



## 1.32 野指针、空指针和悬空指针

### 野指针：

​		野指针是一个被定义了，但未被初始化的指针，或者已被释放的指针。

```cpp
void main(void) {  
    int* p;     // 未初始化
    std::cout<< *p << std::endl; // 未初始化就被使用
}
```

### 空指针：

​		指向空地址的指针被称为空指针

```c++
void main(void)
{
	int* p = nullptr;
}
```

### 悬空指针：

空悬指针是指向已经**被释放（如删除、回收）的内存**的指针。

这种指针仍然具有以前分配的内存地址，但是这块内存可能已经被其他对象或数据占用。

访问空悬指针同样会导致未定义行为。

```c++
void main(void) { 
  int* p = nullptr;
  int* p2 = new int;
  
  p = p2;

  delete p2;
}
```

运行结束之后，指针p和指针p2都是悬空指针。

### 防止野指针和悬空指针的做法：

1、在使用指针前对其进行初始化，如将其初始化为nullptr。

2、在释放指针指向的内存后，将指针设为nullptr，避免误访问已释放的内存。

3、在使用指针前检查其有效性，确保指针指向合法内存。



## 1.33 深拷贝和浅拷贝的区别

### 浅拷贝

浅拷贝仅仅是**指向被复制的内存地址**。**浅拷贝不会开辟新内存，新对象和原对象的成员变量共享同一块地址**。浅拷贝会导致两个对象之间的数据互相影响，如果一个对象修改了共享的数据，另一个对象也会受到影响

### 深拷贝

深拷贝会**创建一个新的对象**，并将原对象中的所有成员变量的值复制到新对象中，**深拷贝会为新的对象开辟新的内存空间存放数据**，原来的对象的数据发生改变不会影响新的对象。



## 1.34 形参和实参的区别

1、形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结束返回主调函数后则不能再使用该形参变量。

2、当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。

3、函数调用中发生的数据传送是单向的。 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。

4、实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。

5、实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。



## 1.35 值传递、指针传递、引用传递的区别和效率

### 值传递：-深拷贝

值传递参数通过复制传递给函数，函数内部对参数的修改不会影响到原始数据，因此需要开辟新的空间存储值，需要拷贝的时间和空间。

### 指针传递：-浅拷贝

指针传递需要传递指针的地址给函数，函数内部通过解引用指针来访问和修改原始数据，，不需要开辟新空间，只需要拷贝一个指针地址。消耗的时间较小。

### 引用传递：-浅拷贝

引用传递需要传递原始数据的一个别名，对引用的修改会直接影响到原始数据，不会开辟新空间。



## 1.36 全局变量和静态变量的初始化时间

在C语言中，在编译阶段，对全局变量和静态变量进行分配内存和初始化。

在C++中，**全局变量、文件域的静态变量和类的静态成员变量**在main执行之前的静态初始化过程中分配内存并初始化；**函数内的局部静态变量**在第一次使用时分配内存并初始化。



## 1.37 大端字节序和小端字节序

### 大端字节序：

**高位字节**存储在**低地址**处，**低位字节**存储在**高地址**处。例如，一个4字节的整数**0x12345678**，在大端字节序的系统中，内存布局如下（从左侧的低地址到右侧的高地址）：

```c++
0x12 | 0x34 | 0x56 | 0x78
```

### 小端字节序：

**低位字节**存储在**低地址**处，**高位字节**存储在高地址处。

例如，一个4字节的整数0x12345678，在小端字节序的系统中，内存布局如下（从左侧的低地址到右侧的高地址）：

```c++
0x78 | 0x56 | 0x34 | 0x12
```

### 使用大端字节序和小端字节序的场景：

大端字节序：网络传输

小端字节序：linux、windows、mac



## 1.38 C++ 几种类型转换

cast就是“强制转换”的意思。

### static_cast

用法: static_cast <new_type> (expression)

用于基本类型之间的转换，以及具有继承关系的类型之间的转换。例如将整数类型转换为浮点数类型，或者将指针类型转换为整数类型。

其实 static_cast 和 C 语言 () 做强制类型转换基本是等价的。`static_cast` 还可以进行基类指针或引用向派生类指针或引用的转换，但在进行这种向下转型时，是不安全的。

注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。

#### static_cast基本类型之间的转换

将一个基本类型转换为另一个基本类型，例如将整数转换为浮点数或将字符转换为整数

```c++
int a = 42;
double b = static_cast<double>(a); // 将整数a转换为双精度浮点数b
```

#### static_cast指针类型之间的转换

##### 下行转换（不安全）

将一个指针类型转换为另一个指针类型，从**基类指针**转换为**派生类指针**。由于没有动态类型检查，所以是不安全的。

```c++
class Base {
public:
    int x;
};

class Derived : public Base {
public:
    int y;
};

Base* base_ptr = new Derived();
Derived* derived_ptr = static_cast<Derived*>(base_ptr); // 将基类指针base_ptr转换为派生类指针derived_ptr
```

##### 上行转换（安全）

将一个指针类型转换为另一个指针类型，从**派生类指针**转换为**基类指针**。

```c++
class Base {
public:
    int x;
};

class Derived : public Base {
public:
    int y;
};

Derived* derivedPtr = new Derived();
Base* basePtr = static_cast<Base*>(derivedPtr);
```

#### static_cast引用类型之间的转换

类似于指针类型之间的转换，可以将一个引用类型转换为另一个引用类型。也是不安全的。

```c++
Derived derived_obj;
Base& base_ref = derived_obj;
Derived& derived_ref = static_cast<Derived&>(base_ref); // 将基类引用base_ref转换为派生类引用derived_ref
```



### dynamic_cast

用法：dynamic_cast<type-id>(expression)

其中type-id必须是指针或者引用。

#### dynamic_cast只能用于指针类型转换和引用类型转换

##### 上行转换

在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的。

##### 下行转换（安全）

1、在进行下行转换时，dynamic_cast具有**类型检查的功能**，比static_cast更安全

2、如果转换失败，dynamic_cast将返回**空指针**（对于指针类型）或**抛出异常**（对于引用类型）

3、使用 dynamic_cast 进行转换的，**基类中一定要有虚函数**，否则编译不通过



### const_cast

用法: const_cast <new_type> (expression) new_type 必须是一个**指针**、**引用**或者**指向对象类型成员的指针**。

功能：用来去除类型的const或volatile属性。

```c++
const int a = 42;
int* mutable_ptr = const_cast<int*>(&a); // 删除const属性，使得可以修改a的值
*mutable_ptr = 43; // 修改a的值
```



### reinterpret_cast

用法：reinterpret_cast<type-id> (expression)

type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。

`reinterpret_cast`通常用于底层的类型转换。`reinterpret_cast` 可以将**任何指针类型**转换为**任何其他指针类型**，或者将一个**整数类型**转换为一个**指针类型**。这种转换是非常危险的，因为它可以绕过类型系统的检查，可能导致未定义的行为，因此这是不安全的行为。



## 1.39 C++ 类对象的初始化和析构顺序

### 1.39.1 类的初始化顺序

#### 1.39.1.1 基类初始化顺序

如果当前类继承自一个或多个基类，它们将按照**声明顺序进行初始化**，但是在有虚继承和一般继承存在的情况下，**优先虚继承**。

比如虚继承：class MyClass : public Base1, public **virtual** Base2，此时应当先调用 Base2 的构造函数，再调用 Base1 的构造函数。

#### 1.39.1.2 成员变量初始化顺序

类的成员变量按照它们在类定义中的**声明顺序进行初始化**（这里一定要注意，成员变量的初始化顺序只与声明的顺序有关！！）

#### 1.39.1.3 类的构造顺序

① 虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）。

② 普通基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）。

③ 类类型的成员对象的构造函数（按照成员对象在类中的定义顺序）

④ 派生类自己的构造函数。

### 1.39.2 类的析构顺序

类的析构顺序和构造顺序完全相反



## 1.40 this指针

`this` 指针是一个隐含的指针，它指向**当前对象**的地址。使用 `this` 指针可以在**类的成员函数**中访问**类的成员变量和成员函数**。

### 1.40.1 this指针解决的两个问题

1、在成员函数中访问成员变量：由于成员变量和成员函数都属于类的对象，所以在成员函数中可以直接访问成员变量。但是，**如果成员变量和函数参数同名，就会发生命名冲突**。这时可以使用 `this` 指针来明确指出要访问的是成员变量而不是函数参数。例如：

```c++
class MyClass {
private:
    int x;
public:
    void setX(int x) //setX 函数的参数名和成员变量名都是 x，为了区分它们，使用 this 指针来访问成员变量。
    {
        this->x = x;
    }
};
```

2、**使用 this 指针实现链式调用**，在成员函数中返回当前对象：使用 `this` 指针可以在成员函数中返回当前对象的引用。

```c++
class MyClass {
private:
    int x;
public:
    MyClass& setX(int x) {
        this->x = x;
        return *this;
    }
};

void main()
{
    MyClass obj;
    obj.setX(10).setX(20);		
}
```

### 1.40.2 静态函数没有 this 指针

注意：`this` 指针只能在非静态成员函数中使用。

静态成员函数没有 `this` 指针，因为它们不属于任何对象，只属于类本身。

可以将 static 函数视为在类作用域下的全局函数，而非成员函数。

```c++
class MyClass {
public:
    static void myStaticFunction() {
        // 以下代码会导致编译错误
        // cout << this->myMemberVariable << endl;
    }
private:
    int myMemberVariable;
};
```



## 1.41 C++中的虚函数表

虚函数表是存放一个类的虚函数的地址表。当一个类声明了虚函数时，编译器会为该类创建一个虚函数表。每个类的对象都会存储一个指向该类虚函数表的指针，这个指针被称为虚函数表指针（vptr）。

当调用一个虚函数时，编译器会通过对象的虚函数指针查找到该对象所属的类的虚函数表，并找到该虚函数对应的虚函数地址。

对于派生类，其虚函数表通常是在基类的虚函数表的基础上扩展而来的。在派生类中，如果重写了基类的虚函数，那么该函数在派生类的虚函数表中的地址会被更新为指向派生类中实际实现该函数的代码地址。



## 1.42 纯虚函数

纯虚函数是一种在基类中声明但没有实现的虚函数。

纯虚函数在基类中起到了一个接口的作用，它要求任何派生类都必须提供自己的实现。如果一个派生类没有实现基类中的纯虚函数，那么这个派生类也会成为一个抽象类，无法实例化。

纯虚函数的声明如下：

```c++
virtual void function() = 0;
```

注意：纯虚函数只有声明，没有定义。它没有函数体，因为它的实现是由派生类提供的。

```c++
#include <iostream>
using namespace std;

class Shape {
   public:
      // 纯虚函数
      virtual void draw() = 0;
};

class Circle : public Shape {
   public:
      void draw() {
         cout << "画一个圆形" << endl;
      }
};

class Square : public Shape {
   public:
      void draw() {
         cout << "画一个正方形" << endl;
      }
};

int main() {
   Circle circle;
   Square square;

   Shape *pShape1 = &circle;
   Shape *pShape2 = &square;

   pShape1->draw();		//显示：画一个圆形
   pShape2->draw();		//显示：画一个正方形

   return 0;
}
```



## 1.43 为什么 C++ 构造函数不能是虚函数？

### 1.43.1 从语法层面来说

虚函数的主要目的是实现多态，即允许在派生类中覆盖基类的成员函数。

但是，构造函数负责初始化类的对象，每个类都应该有自己的构造函数。

在派生类中，基类的构造函数会被自动调用，用于初始化基类的成员。因此，构造函数没有被覆盖的必要，不需要使用虚函数来实现多态。

### 1.43.3 从虚函数表机制来说

虚函数使用了一种称为虚函数表（vtable）的机制。虚函数表指针在构造函数之后才创建，构造函数中使用虚函数表会导致未定义的行为。



## 1.44 为什么C++基类析构函数需要是虚函数？

### 1.44.1 析构函数作用：

析构函数是进行类的清理工作，比如释放内存、关闭数据库连接、关闭网络连接等等

### 1.44.2 为什么需要是虚函数

因为当父类指针指向子类对象时,如果析构函数不是虚函数,析构就只会释放父类对象,造成内存泄漏





# 2 内存管理

## 2.1 内存分区

![image-20230712211718180](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230712211718180.png)

### 2.1.1代码区

也就是 .text 段， 代码区存放**程序的二进制代码**，它是只读的，以防止程序在运行过程中被意外修改。

### 2.1.2 全局/静态存储区

全局/静态存储区存放**全局变量**和**静态变量**。

静态存储区又可分为未初始化的 .bss段和初始化过的 .data段。

### 2.1.3 堆区（Heap）

堆区是用于**动态内存分配的区域**，当使用**new（C++）**或者**malloc（C）**分配内存时，分配的内存块就位于堆区。

我们需要**手动释放**这些内存，否则可能导致**内存泄漏**。

### 2.1.4 栈区（Stack）

栈区用于存储函数调用时的**局部变量**、**函数参数**以及**返回地址**。

当函数调用完成后，分配给这个函数的栈空间会被**释放**。

```c++
#include <iostream>
void function(int a, int b) {
    int localVar = a + b;
    std::cout << localVar << std::endl;
}
int main() {
    function(3, 4);
    return 0;
}
```

示例：

a、b和localVar都是局部变量，它们存放在栈区。

当 function 函数调用结束后，对应的函数栈所占用的空间(参数 a、b，局部变量 localVar等)都会被回收

### 2.1.5 常量区（Constant Storage）

常量区用于存储常量数据，例如字符串字面量和其他编译时常量。这个区域通常也是只读的，不可以修改。

```c++
#include <iostream>
int main() {
	char* c="abc";  // abc在常量区，c在栈上。
  return 0;
}
```



## 2.2 内存泄漏

在程序中申请了动态内存，却没有释放，如果程序长期运行下去，最终会导致没有内存可供分配。

具体操作是

1、`new`之后没有`delete`或者`malloc`之后没有`free`

2、子类继承父类时，父类析构函数不是虚函数。如果此时是父类指针指向子类对象，则无法调用子类析构函数。

### 2.2.2 如何避免内存泄漏

1、手动检查代码：仔细检查代码中的内存分配和释放，确保每次分配内存后都有相应的释放操作。比如 malloc和free、new和delete是否配对使用了。

2、使用调试器和工具：有一些工具可以帮助检测内存泄露。例如：

![image-20230712231544613](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230712231544613.png)

3、使用智能指针（C++）：在C++中，可以使用智能指针（如std::unique_ptr和std::shared_ptr）来自动管理内存。这些智能指针在作用域结束时会自动释放所指向的内存，从而降低忘记释放内存或者程序异常导致内存泄露的风险。

4、异常安全：在C++中，如果程序抛出异常，需要确保在异常处理过程中正确释放已分配的内存。使用try-catch块来捕获异常并在适当的位置释放内存。



## 2.3 智能指针

智能指针是一种可以**自动管理内存**的指针，它可以在**不需要手动释放内存**的情况下，确保对象被正确地销毁。

这种指针可以显著降低程序中的内存泄漏和悬空指针的风险。

### 2.3.1 std::unique_ptr

`std::unique_ptr`是一个**独占所有权**的智能指针，它保证指向的内存只能由一个`unique_ptr`拥有，**不能共享所有权**。

当`unique_ptr`**超出作用域**时，它所指向的内存会**自动释放**。

```c++
#include <memory>
#include <iostream>

int main() {
    std::unique_ptr<int> ptr(new int(10));
    std::cout << *ptr << std::endl; // 输出10
    // unique_ptr在超出作用域时自动释放所拥有的内存
    return 0;
}
```

### 2.3.2 std::shared_ptr

`std::shared_ptr`是一个**共享所有权**的智能指针，它允许**多个`shared_ptr`指向同一个对象**，当**最后一个拥有该对象的 `shared_ptr` 被销毁或者释放该对象的所有权**时，对象会自动被删除。

```c++
#include <memory>
#include <iostream>

int main() {
    std::shared_ptr<int> ptr1(new int(10));
    std::shared_ptr<int> ptr2 = ptr1; // 通过拷贝构造函数创建一个新的shared_ptr，此时引用计数为2
    std::cout << *ptr1 << " " << *ptr2 << std::endl; // 输出10 10
    // ptr2超出作用域时，所指向的内存不会被释放，因为此时ptr1仍然持有对该内存的引用
    return 0;
}
```

### 2.3.3 std::weak_ptr----TODO



## C/C++ malloc-free底层原理-动态内存管理----TODO

### malloc 和 free

malloc 和 free 是 C 语言中用于动态内存分配和释放内存的两个函数。

它们是 C 语言标准库的一部分，用于在程序运行期间请求和释放堆内存。



## C++ new、delete 和malloc、free区别

### 用法：

```c++
#include <cstdlib>

int main() {
    // 使用 malloc 分配内存
    int *ptr = (int *)malloc(sizeof(int));
    // 记得在使用完之后释放内存
    free(ptr);
}
```

```c++
int main() {
    // 使用 new 分配内存并调用构造函数
    int *ptr = new int;
    // 记得在使用完之后释放内存
    delete ptr;
}
```

### 简单对比：

语法不同：malloc/free是一个C语言的函数，而new/delete是C++的运算符。

分配内存的方式不同：malloc只分配内存，而new会分配内存并且调用对象的构造函数来初始化对象。

是否自动分配内存大小的不同：malloc 需要传入需要分配的大小，而 new 编译器会自动计算所构造对象的大小

返回值不同：malloc返回一个 void 指针，需要自己强制类型转换，而new返回一个指向对象类型的指针。



#### 申请的内存所在位置：

**new** 操作符从**自由存储区（free store）**上为对象动态分配内存空间，而**malloc**函数从**堆**上动态分配内存。

**自由存储区**是 C++ 基于new操作符的一个抽象概念，**凡是通过 new 操作符进行内存申请，该内存即为自由存储区**。

**堆**是操作系统中的术语，是操作系统所维护的一块特殊内存，**用于程序的内存动态分配**，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。

几乎可以将自由存储区**等价于**堆区。



#### 内存分配失败时返回值：

 **new** 内存分配失败时，会**抛出 bac_alloc 异常**，它**不会返回 NULL** ； **malloc** 分配内存失败时**返回 NULL** 。

判断 new 内存分配是否成功代码如下：

```c++
try {
    int *a = new int();
} catch (bad_alloc) {
    ...
}
```

判断 malloc 内存分配是否成功代码如下：

```c++
int *a  = (int *)malloc ( sizeof (int ));
if(NULL == a) {		// malloc 内存分配失败
    ...
} else {			// malloc 内存分配成功
    ...
}
```



#### 是否调用构造函数/析构函数：

malloc 不会调用构造函数/析构函数

**使用new操作符来分配对象内存时会经历三个步骤：**

第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。

第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。

第三部：对象构造完成后，返回一个指向该对象的指针。

**使用delete操作符来释放对象内存时会经历两个步骤：**

第一步：调用对象的析构函数。

第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。



#### 对数组的处理：

C++ 提供了 new[] 与 delete[] 来专门处理数组类型，使用 new[] 分配的内存必须使用 delete[] 进行释放：

```c++
A * ptr = new A[10];//分配10个A对象
delete [] ptr;
```

new 对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。



malloc 不知道你在这块内存上要什么类型的数据，malloc会给你一块原始的内存。如果要动态分配一个数组的内存，还需要我们手动自定数组的大小：

```c++
int * ptr = (int *) malloc( sizeof(int)* 10 );//分配一个10个int元素的数组
```



#### new 和 malloc 是否可以相互调用：

C++实现中， new 调用了 malloc ， delete 调用了 free 。



#### 能够直观地重新分配内存：

**malloc：**

使用 malloc 分配的内存后，如果在使用过程中发现内存不足，可以使用 realloc 函数进行内存重新分配实现内存的扩充。

realloc 先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；

如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。

**new：**

new 没有这样直观的配套设施来扩充内存。



表格总结：

|         特征         |              new/delete               |             malloc/free              |
| :------------------: | :-----------------------------------: | :----------------------------------: |
|    分配内存的位置    |              自由存储区               |                  堆                  |
| 内存分配成功的返回值 |             完整类型指针              |                void*                 |
| 内存分配失败的返回值 |         默认抛出异常bac_alloc         |               返回NULL               |
|    分配内存的大小    |   由编译器根据类型计算得出（自动）    |      必须显式指定字节数（手动）      |
|       处理数组       |       有处理数组的new版本new[]        | 需要用户计算数组的大小后进行内存分配 |
|   已分配内存的扩充   |            无法直观地处理             |         使用realloc简单完成          |
|     是否相互调用     | 可以，看具体的operator new/delete实现 |             不可调用new              |
|  分配内存时内存不足  | 客户能够指定处理函数或重新制定分配器  |       无法通过用户代码进行处理       |
|       函数重载       |                 允许                  |                不允许                |
|  构造函数与析构函数  |                 调用                  |                不调用                |



## nullptr 和 NULL的区别



C++11之前，使用 NULL 表示空指针，但是 NULL 的定义其实是一个整数值 0 ，而不是一个真正的指针。

C++11之后，引入 nullptr 表示空指针，nullptr 是一种特殊类型的字面值，是一个真正的指针类型。





构造函数 -虚函数



在RTOS中如何避免内存泄漏？

答：

空闲任务会释放被删除任务的内存，但是不会帮忙释放用户在任务中自己申请的内存，所以在删除任务之前，程序员需要自己手动释放在该任务中申请的内存。
